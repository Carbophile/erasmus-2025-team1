<!doctype html>
<html lang="hr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Quiz - QuizBattle</title>
    <link href="../questions/css/questions.css" rel="stylesheet" />
    <style>
        .fade-out {
            opacity: 0;
            transition: opacity 0.3s;
        }

        .fade-in {
            opacity: 1;
            transition: opacity 0.3s;
        }

        .finish-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .answer.disabled {
            pointer-events: none;
            opacity: 0.6;
        }

        .answer.correct {
            background: #2e8b57 !important;
            color: #fff;
        }

        .answer.incorrect {
            background: #b22222 !important;
            color: #fff;
        }

        .answer.show-correct {
            outline: 2px solid #2e8b57;
        }

        .feedback-banner {
            margin-top: 8px;
            font-size: 0.9rem;
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="card" id="app">
        <h1>Quiz Beginner</h1>
        <div class="meta-row">
            <div class="lives" id="lives">
                <span class="heart">‚ù§Ô∏è</span>
                <span class="heart">‚ù§Ô∏è</span>
                <span class="heart">‚ù§Ô∏è</span>
            </div>
            <div class="timer" id="timer">00:05</div>
            <div class="points" id="points">Score: 0</div>
        </div>
        <div class="card-content">
            <div class="quiz-content" id="quiz-root">
            </div>
        </div>
    </div>

    <script>
        // Backend-integrated quiz (all life/score correctness server-side)
        const API = {
            start: (quiz_id) => fetch('/quiz/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ quiz_id })
            }).then(r => r.json()),
            answer: (state, answer) => fetch('/quiz/answer', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ state, answer })
            }).then(r => r.json()),
            saveResult: (token, quiz_id, score, time_taken) => fetch('/quiz/result', {
                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                body: JSON.stringify({ quiz_id, score, time_taken })
            }).then(r => r.json())
        };

        const livesContainer = document.getElementById('lives');
        const timerElement = document.getElementById('timer');
        const pointsElement = document.getElementById('points');
        const root = document.getElementById('quiz-root');

        let signedState = null;
        let currentQuestion = null;
        let lives = 3;
        let score = 0;
        let quizStartTime = Date.now();
        let timerInterval = null;
        const QUESTION_TIME = 5; // seconds UI (authoritative server-side)
        let firstQuizId = null;
        let pendingNext = false;
        let lastFeedback = null;

        function updateLivesDisplay() {
            const hearts = livesContainer.querySelectorAll('.heart');
            hearts.forEach((h, i) => {
                if (i >= lives) { h.classList.add('lost'); h.textContent = 'üíî'; }
                else { h.classList.remove('lost'); h.textContent = '‚ù§Ô∏è'; }
            });
        }

        function setTimer(seconds) {
            clearInterval(timerInterval);
            let remaining = seconds;
            renderTimer(remaining);
            timerInterval = setInterval(() => {
                remaining--;
                renderTimer(remaining);
                if (remaining < 0) { // timeout -> send null answer
                    clearInterval(timerInterval);
                    lockAnswers();
                    sendAnswer(null); // server will deduct life and either continue or end
                }
            }, 1000);
        }

        function renderTimer(sec) {
            if (sec < 0) sec = 0;
            const mins = String(Math.floor(sec / 60)).padStart(2, '0');
            const secs = String(sec % 60).padStart(2, '0');
            timerElement.textContent = `${mins}:${secs}`;
        }

        function renderQuestion(q) {
            root.innerHTML = `
                <div class="meta-block">
                    <div class="progress" id="progress">Difficulty: ${q.difficulty || ''}</div>
                    <div class="question-block">
                        <div class="question" id="question">${q.text}</div>
                    </div>
                </div>
                <div class="answers" id="answers"></div>
                <div id="resultArea"></div>
            `;
            const answersDiv = root.querySelector('#answers');
            (q.options || []).forEach(opt => {
                const div = document.createElement('div');
                div.className = 'answer fade-in';
                div.textContent = opt.option;
                div.dataset.optionId = opt.id;
                div.addEventListener('click', () => selectAnswer(opt.id, div));
                answersDiv.appendChild(div);
            });
            if (!firstQuizId) firstQuizId = q.quiz_id; // remember first quiz id for result association
            setTimer(QUESTION_TIME);
            lastFeedback = null;
            pendingNext = false;
        }

        function lockAnswers() {
            const answers = root.querySelectorAll('.answer');
            answers.forEach(a => a.classList.add('disabled'));
        }

        function selectAnswer(id, el) {
            lockAnswers();
            el.classList.add('selected');
            clearInterval(timerInterval);
            sendAnswer(id);
        }

        async function sendAnswer(answerId) {
            if (!signedState) return;
            try {
                const res = await API.answer(signedState, answerId);
                if (!res.success) throw new Error(res.error || 'Answer failed');
                lastFeedback = res.last || null;
                applyAnswerFeedback(lastFeedback);
                if (res.game_over) {
                    lives = res.lives ?? 0;
                    score = res.final_score ?? 0;
                    updateLivesDisplay();
                    // delay a moment to show feedback
                    setTimeout(() => showGameOver(res), 800);
                    return;
                }
                signedState = res.state;
                lives = res.lives;
                score = res.score;
                updateLivesDisplay();
                pointsElement.textContent = `Score: ${score}`;
                currentQuestion = res.question;
                // wait before moving to next question so user sees feedback
                if (!pendingNext) {
                    pendingNext = true;
                    setTimeout(() => renderQuestion(currentQuestion), 800);
                }
            } catch (e) {
                console.error(e);
                alert('Network / server error answering question.');
            }
        }

        function applyAnswerFeedback(feedback) {
            if (!feedback) return;
            const answersDiv = root.querySelector('#answers');
            if (!answersDiv) return;
            const given = feedback.answer_given;
            const correctId = feedback.correct_option_id;
            const children = Array.from(answersDiv.children);
            children.forEach(ch => {
                const oid = ch.dataset.optionId;
                if (oid == correctId) ch.classList.add('correct');
                if (given != null && oid == given && given != correctId) ch.classList.add('incorrect');
                if (oid == correctId && given != correctId) ch.classList.add('show-correct');
            });
            const fb = document.createElement('div');
            fb.className = 'feedback-banner';
            if (feedback.timeout) fb.textContent = 'Time ran out! Correct answer shown.';
            else if (feedback.correct) fb.textContent = 'Correct!';
            else fb.textContent = 'Incorrect! Correct answer highlighted.';
            root.querySelector('#resultArea')?.appendChild(fb);
        }

        function showGameOver(res) {
            // apply last feedback if not yet applied
            applyAnswerFeedback(lastFeedback);
            clearInterval(timerInterval);
            timerElement.textContent = '00:00';
            const reason = res.reason;
            const finalScoreText = reason === 'no_lives' ? 'Score discarded (no lives left)' : `Final Score: ${score}`;
            root.innerHTML = `
                <div class="result game-over finish-center fade-in">
                    <strong>${reason === 'no_lives' ? 'Game Over!' : 'Quiz Finished!'}</strong><br>
                    ${finalScoreText}<br>
                    <div style="margin-top:1rem;">Lives remaining: ${lives}</div>
                    <a id="goHomeLink" href="../leadeboard/home.html" style="margin-top:30px; padding:12px 32px; border-radius:10px; background:#FF76CE; color:#fff; font-size:1.1rem; border:none; cursor:pointer; text-decoration:none; display:inline-block;">Go to Home</a>
                </div>`;
            const link = document.getElementById('goHomeLink');
            if (link) link.addEventListener('click', e => { e.preventDefault(); document.body.style.opacity = '0'; setTimeout(() => location.href = link.getAttribute('href'), 300); });

            if (reason !== 'no_lives') {
                const token = localStorage.getItem('authToken');
                if (token && firstQuizId) {
                    API.saveResult(token, firstQuizId, score, Math.round((Date.now() - quizStartTime) / 1000)).then(r => {
                        if (!r?.success) console.warn('Result save failed');
                    }).catch(() => { });
                }
            }
        }

        async function startQuiz() {
            try {
                const quiz_id = new URLSearchParams(location.search).get('quiz_id');
                const res = await API.start(quiz_id);
                if (!res.success) {
                    root.innerHTML = `<div class="result game-over">${res.error || 'Failed to start quiz.'}</div>`;
                    return;
                }
                signedState = res.state;
                lives = res.lives;
                score = res.score;
                quizStartTime = Date.now();
                pointsElement.textContent = `Score: ${score}`;
                updateLivesDisplay();
                currentQuestion = res.question;
                renderQuestion(currentQuestion);
            } catch (e) {
                console.error(e);
                root.innerHTML = '<div class="result game-over">Server not reachable.</div>';
            }
        }

        // Kick off
        startQuiz();
    </script>
</body>

</html>
